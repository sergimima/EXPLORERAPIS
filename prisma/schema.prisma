// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ==================================================
// MULTI-TENANT: Usuarios, Organizaciones y Tokens
// ==================================================

model User {
  id              String    @id @default(cuid())
  email           String    @unique
  name            String?
  hashedPassword  String?   // Null si usa OAuth
  emailVerified   DateTime?
  image           String?
  role            UserRole  @default(MEMBER)

  // NextAuth fields
  accounts        Account[]
  sessions        Session[]

  // Multi-tenant
  organizationId  String?
  organization    Organization? @relation(fields: [organizationId], references: [id])
  memberships     OrganizationMember[]
  sentInvitations Invitation[] @relation("SentInvitations")

  // Metadata
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  lastLoginAt     DateTime?

  @@index([email])
  @@index([organizationId])
  @@map("users")
}

enum UserRole {
  SUPER_ADMIN  // Platform admin
  ADMIN        // Org admin
  MEMBER       // Org member
  VIEWER       // Read-only
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ==================================================
// ORGANIZACIONES (Tenants)
// ==================================================

model Organization {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique  // URL-friendly
  logoUrl     String?  // Cloudinary URL del logo
  website     String?

  // Owner
  ownerId     String

  // Relations
  users       User[]
  members     OrganizationMember[]
  tokens      Token[]
  invitations Invitation[]

  // Suscripción
  subscription Subscription?
  usageStats   UsageStats[]

  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([slug])
  @@index([ownerId])
  @@map("organizations")
}

model OrganizationMember {
  id             String       @id @default(cuid())
  organizationId String
  userId         String
  role           MemberRole   @default(MEMBER)
  invitedBy      String?
  invitedAt      DateTime     @default(now())
  joinedAt       DateTime?

  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId])
  @@index([userId])
  @@map("organization_members")
}

enum MemberRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

// ==================================================
// INVITATIONS (Sprint 2.5)
// ==================================================

model Invitation {
  id             String      @id @default(cuid())
  organizationId String
  email          String
  role           MemberRole  @default(MEMBER)
  token          String      @unique
  invitedBy      String
  expiresAt      DateTime
  acceptedAt     DateTime?
  createdAt      DateTime    @default(now())

  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  inviter        User         @relation("SentInvitations", fields: [invitedBy], references: [id])

  @@index([token])
  @@index([organizationId])
  @@index([email])
  @@map("invitations")
}

// ==================================================
// TOKENS (Multi-token support)
// ==================================================

model Token {
  id             String   @id @default(cuid())
  organizationId String

  // Token info
  address        String
  symbol         String
  name           String
  decimals       Int      @default(18)
  network        String   @default("base")
  logoUrl        String?  // Cloudinary URL del logo

  // Status
  isActive       Boolean  @default(true)
  isVerified     Boolean  @default(false)

  // Settings
  settings       TokenSettings?

  // Custom ABIs y Contracts (Sprint 2.2)
  customAbis     CustomAbi[]
  contracts      Contract[]

  // Relations (data aislado por token)
  knownAddresses          KnownAddress[]
  transferCache           TransferCache[]
  holderSnapshots         HolderSnapshot[]
  tokenSupplyCache        TokenSupplyCache[]
  vestingCache            VestingCache[]
  vestingTransferCache    VestingTransferCache[]
  vestingBeneficiaryCache VestingBeneficiaryCache[]
  vestingContractCache    VestingContractCache[]

  // Metadata
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  createdBy      String?

  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([organizationId, address, network])
  @@index([organizationId])
  @@index([address])
  @@map("tokens")
}

model TokenSettings {
  id                    String   @id @default(cuid())
  tokenId               String   @unique

  // API Keys personalizadas (opcionales)
  customBasescanApiKey    String?
  customEtherscanApiKey   String?
  customMoralisApiKey     String?
  customQuiknodeUrl       String?
  customRoutescanApiKey   String?

  // Configuraciones
  cacheDurationMinutes    Int      @default(5)
  maxTransfersToFetch     Int      @default(10000)
  whaleThreshold          String   @default("10000")

  // Exchanges custom
  customExchangeAddresses String[]

  // Supply Configuration (Sprint 2.3)
  supplyMethod              String?  @default("API") // "API" o "ONCHAIN"
  supplyApiTotalUrl         String?  // URL para total supply
  supplyApiCirculatingUrl   String?  // URL para circulating supply

  // Metadata
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  token                   Token    @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  @@map("token_settings")
}

// ==================================================
// CUSTOM ABIs Y VESTING CONTRACTS (Sprint 2.2)
// ==================================================

model CustomAbi {
  id              String   @id @default(cuid())
  tokenId         String
  contractAddress String   // Dirección del contrato (token o vesting)
  network         String   // "base", "base-testnet", "base-sepolia"

  // ABI data
  abi             Json     // ABI en formato JSON
  source          String   @default("STANDARD") // STANDARD, UPLOADED, BASESCAN, ROUTESCAN

  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  token           Token    @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  @@unique([tokenId, contractAddress, network])
  @@map("custom_abis")
}

enum ContractCategory {
  VESTING      // Vesting contracts (token release schedules)
  STAKING      // Staking contracts
  LIQUIDITY    // Liquidity pools
  DAO          // DAO governance contracts
  TREASURY     // Treasury/reserve contracts
  MARKETING    // Marketing wallets/contracts
  TEAM         // Team allocation contracts
  OTHER        // Other contract types
}

model Contract {
  id          String            @id @default(cuid())
  tokenId     String

  // Información del contrato
  name        String            // "Vottun World", "Investors", "Uniswap Pool", etc.
  address     String            // Dirección del contrato
  network     String            @default("base")
  category    ContractCategory  @default(OTHER)

  // Status y metadata
  isActive    Boolean  @default(true)
  description String?

  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?

  token       Token    @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  @@unique([tokenId, address, network])
  @@index([tokenId])
  @@index([address])
  @@index([category])
  @@map("contracts")
}

// ==================================================
// SUBSCRIPTIONS & BILLING
// ==================================================

model Plan {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  price       Decimal  @default(0)
  currency    String   @default("USD")

  // Stripe (para futuro)
  stripePriceId String?

  // Límites configurables (-1 = ilimitado)
  tokensLimit     Int  @default(1)
  apiCallsLimit   Int  @default(10000)
  transfersLimit  Int  @default(10000)
  membersLimit    Int  @default(1)

  // Features adicionales
  features    Json?    // Array de strings: ["webhooks", "priority-support"]

  // Metadata
  isActive    Boolean  @default(true)
  isPublic    Boolean  @default(true)
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  subscriptions Subscription[]

  @@index([slug])
  @@index([isActive])
  @@map("plans")
}

model Subscription {
  id                String   @id @default(cuid())
  organizationId    String   @unique

  // Stripe
  stripeCustomerId      String?  @unique
  stripeSubscriptionId  String?  @unique
  stripePriceId         String?
  stripeCurrentPeriodEnd DateTime?

  // Plan
  planId            String?  // FK a Plan (nullable para legacy)
  plan              SubscriptionPlan @default(FREE) // Deprecado, mantener por compatibilidad
  status            SubscriptionStatus @default(ACTIVE)

  // Usage tracking
  apiCallsThisMonth Int      @default(0)
  apiCallsLimit     Int      @default(1000)
  tokensCount       Int      @default(0)
  tokensLimit       Int      @default(1)
  transfersLimit    Int      @default(10000)
  membersLimit      Int      @default(1)

  // Billing
  billingCycleStart DateTime @default(now())
  billingCycleEnd   DateTime?

  // Metadata
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  canceledAt        DateTime?

  organization      Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  planRelation      Plan?        @relation(fields: [planId], references: [id])

  @@index([organizationId])
  @@index([planId])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@map("subscriptions")
}

enum SubscriptionPlan {
  FREE
  PRO
  ENTERPRISE
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  TRIALING
}

model UsageStats {
  id             String   @id @default(cuid())
  organizationId String
  date           DateTime @default(now())

  // Métricas
  apiCalls         Int      @default(0)
  transfersFetched Int      @default(0)
  holdersFetched   Int      @default(0)

  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([organizationId, date])
  @@index([organizationId])
  @@map("usage_stats")
}

model SystemSettings {
  id    String   @id @default("system") // Singleton: siempre el mismo ID

  // API Keys globales (default para todas las orgs)
  defaultBasescanApiKey  String?
  defaultEtherscanApiKey String?
  defaultMoralisApiKey   String?
  defaultQuiknodeUrl     String?
  defaultRoutescanApiKey String?

  // Email (Resend)
  resendApiKey    String?
  resendFromEmail String?
  resendFromName  String?

  // Stripe (para futuro)
  stripePublicKey    String?
  stripeSecretKey    String?
  stripeWebhookSecret String?

  // Cloudinary (logos de orgs y tokens)
  cloudinaryCloudName  String?
  cloudinaryApiKey     String?
  cloudinaryApiSecret  String?

  // General
  appName      String  @default("TokenLens")
  appUrl       String  @default("http://localhost:4200")
  supportEmail String?

  // Metadata
  updatedAt DateTime @updatedAt
  updatedBy String?  // userId del SUPER_ADMIN que actualizó

  @@map("system_settings")
}

// ==================================================
// FASE 1: Etiquetado y Caché Básico
// ==================================================

model KnownAddress {
  id          String   @id @default(cuid())
  tokenId     String?  // FK a Token (nullable para datos legacy)
  address     String
  name        String
  type        AddressType
  category    String?
  description String?
  tags        String[] // Array de tags: ["vesting", "important", "monitored"]
  color       String?  // Color hex para UI
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  token       Token?   @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  @@unique([tokenId, address]) // Único por token
  @@index([tokenId])
  @@index([address])
  @@index([type])
  @@index([category])
  @@map("known_addresses")
}

enum AddressType {
  CONTRACT
  WALLET
  EXCHANGE
  VESTING
  TOKEN
  UNKNOWN
}

model TokenSupplyCache {
  id                String   @id @default(cuid())
  tokenId           String?  // FK a Token (nullable para datos legacy)
  tokenAddress      String
  network           String
  totalSupply       String
  circulatingSupply String
  lockedSupply      String
  cachedAt          DateTime @default(now())
  expiresAt         DateTime

  token             Token?   @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  @@unique([tokenAddress, network])
  @@index([tokenId])
  @@index([expiresAt])
  @@map("token_supply_cache")
}

// Caché incremental de transferencias (solo agrega nuevos)
model TransferCache {
  id            String   @id @default(cuid())
  tokenId       String?  // FK a Token (nullable durante migración)
  hash          String
  tokenAddress  String
  tokenSymbol   String?  // Nuevo: Para mostrar en el historial
  tokenName     String?  // Nuevo: Para mostrar en el historial
  decimals      Int      @default(18)  // Decimales del token para formatear cantidades
  from          String
  to            String
  value         String
  timestamp     BigInt   // Unix timestamp para ordenar y buscar últimos
  blockNumber   Int
  network       String   @default("base")
  cachedAt      DateTime @default(now())

  token         Token?   @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  @@unique([tokenId, hash]) // Único por token
  @@index([tokenId, timestamp])
  @@index([tokenId, network])
  @@index([tokenAddress, timestamp])  // Para buscar transfers y último timestamp
  @@index([tokenAddress, network])
  @@index([from])
  @@index([to])
  @@index([hash])
  @@map("transfer_cache")
}

// Snapshots periódicos de holders (reemplaza snapshot completo cada vez)
model HolderSnapshot {
  id           String   @id @default(cuid())
  tokenId      String?  // FK a Token (nullable durante migración)
  tokenAddress String
  network      String   @default("base")
  timestamp    DateTime @default(now())
  holders      Holder[]

  token        Token?   @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  @@index([tokenId, network, timestamp])
  @@index([tokenAddress, network, timestamp])
  @@map("holder_snapshots")
}

// Holders individuales dentro de un snapshot
model Holder {
  id         String   @id @default(cuid())
  snapshotId String
  address    String
  balance    String
  percentage Float
  isContract Boolean  @default(false)
  isExchange Boolean  @default(false)
  label      String?  // Nombre si está en KnownAddress

  snapshot   HolderSnapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)

  @@index([address])
  @@index([snapshotId])
  @@map("holders")
}

// Caché de información de vesting por wallet y contrato
model VestingCache {
  id                    String   @id @default(cuid())
  tokenId               String?  // FK a Token (nullable durante migración)
  walletAddress         String
  vestingContractAddress String
  network               String   @default("base")

  // Información del token
  tokenName             String
  tokenSymbol           String
  tokenAddress          String

  // Cantidades
  totalAmount           String
  vestedAmount          String
  claimableAmount       String
  remainingAmount       String
  releasedAmount        String

  // Timestamps
  startTime             BigInt
  endTime               BigInt
  nextUnlockTime        BigInt?
  nextUnlockAmount      String?

  // Configuración de vesting
  slicePeriodSeconds    Int?
  cliff                 Int?
  cliffEndTime          BigInt?

  // Metadatos de caché
  cachedAt              DateTime @default(now())
  updatedAt             DateTime @updatedAt

  token                 Token?   @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  @@unique([tokenId, walletAddress, vestingContractAddress, network])
  @@index([tokenId])
  @@index([walletAddress])
  @@index([vestingContractAddress])
  @@map("vesting_cache")
}

// Tabla SEPARADA para transferencias de contratos de vesting
model VestingTransferCache {
  id            String   @id @default(cuid())
  tokenId       String?  // FK a Token (nullable durante migración)
  hash          String
  tokenAddress  String
  tokenSymbol   String?
  tokenName     String?
  decimals      Int      @default(18)
  from          String
  to            String
  value         String
  timestamp     BigInt
  blockNumber   Int
  network       String   @default("base")
  vestingContract String // Dirección del contrato de vesting
  cachedAt      DateTime @default(now())

  token         Token?   @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  @@unique([tokenId, hash, vestingContract]) // Mismo hash puede estar en múltiples vestings y tokens
  @@index([tokenId])
  @@index([vestingContract, tokenAddress, timestamp])
  @@index([vestingContract, network])
  @@index([from])
  @@index([to])
  @@map("vesting_transfer_cache")
}

// Tabla para beneficiarios de contratos de vesting
model VestingBeneficiaryCache {
  id                  String   @id @default(cuid())
  tokenId             String?  // FK a Token (nullable durante migración)
  vestingContract     String   // Dirección del contrato de vesting
  beneficiaryAddress  String   // Dirección del beneficiario
  network             String   @default("base")

  // Información del token
  tokenAddress        String
  tokenSymbol         String
  tokenName           String

  // Cantidades
  totalAmount         String
  vestedAmount        String
  releasedAmount      String
  claimableAmount     String
  remainingAmount     String

  // Tiempos
  startTime           BigInt
  endTime             BigInt

  // Metadatos
  cachedAt            DateTime @default(now())
  updatedAt           DateTime @updatedAt

  token               Token?   @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  // Relación con schedules individuales
  vestings            VestingScheduleCache[]

  @@unique([tokenId, vestingContract, beneficiaryAddress, network])
  @@index([tokenId])
  @@index([vestingContract])
  @@index([beneficiaryAddress])
  @@map("vesting_beneficiary_cache")
}

// Caché de totales calculados por contrato de vesting
model VestingContractCache {
  id              String   @id @default(cuid())
  tokenId         String
  contractAddress String
  network         String   @default("base")

  // Totales calculados
  totalTokensIn      String  @default("0")
  totalTokensOut     String  @default("0")
  lockedTokens       String  @default("0")
  releasableTokens   String  @default("0")
  claimedTokens      String  @default("0")

  // Control de sincronización
  lastUpdate         DateTime @default(now())
  lastBlockNumber    BigInt   @default(0)
  lastTransferHash   String?  // Hash de la última transferencia procesada

  token              Token    @relation(fields: [tokenId], references: [id], onDelete: Cascade)

  @@unique([tokenId, contractAddress, network])
  @@index([tokenId])
  @@index([contractAddress])
  @@index([lastUpdate])
  @@map("vesting_contract_cache")
}

// Tabla para schedules individuales de vesting por beneficiario
model VestingScheduleCache {
  id                        String   @id @default(cuid())
  beneficiaryId             String   // Relación con VestingBeneficiaryCache
  scheduleId                String   // ID del schedule en el contrato (bytes32)

  phase                     String   // Nombre de la fase
  cliff                     Int      // Tiempo de cliff en segundos
  start                     BigInt   // Timestamp de inicio
  duration                  Int      // Duración total en segundos
  amountTotal               String   // Monto total asignado
  claimFrequencyInSeconds   Int      // Frecuencia de claim en segundos
  lastClaimDate             BigInt   // Último timestamp de claim
  released                  String   // Tokens ya liberados/reclamados
  revoked                   Boolean  // Si fue revocado

  // Metadatos
  cachedAt                  DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  beneficiary               VestingBeneficiaryCache @relation(fields: [beneficiaryId], references: [id], onDelete: Cascade)

  @@index([beneficiaryId])
  @@index([scheduleId])
  @@map("vesting_schedule_cache")
}
